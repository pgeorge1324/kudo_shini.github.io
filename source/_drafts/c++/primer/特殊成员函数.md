# 特殊成员函数

## 1.C++自动提供下面这些成员函数

- 默认构造函数，如果没有定义构造函数;

  - 无参数的构造函数
  - 带参数的构造函数（所有参数都有默认值）
  - 如果上述二者都有会产生二义性

- 默认析构函数，如果没有定义;

- 复制构造函数，如果没有定义;

  - 将一个对象复制到新创建的对象中时使用

    - 新建对象初始化

      ```
      StringBad motto;
      StringBad ditto(motto);//calls StringBad(const StringBad &)
      StringBad metoo = motto;//calls StringBad(const StringBad &)
      StringBad also = StringBad(motto);//calls StringBad(const StringBad &)
      StringBad * pStringBad = new StringBad(motto);//calls StringBad(const StringBad &)
      ```

      

    - 函数调用（按值传递时）

    - 编译器生成临时对象时（函数返回对象）

  - 隐式复制构造函数

    - 浅拷贝，当成员是指针的时候，新对象和老对象指向该成员指向同一内存，会导致析构函数中重复释放该内存

  - 显示复制构造函数

    - 需自定义
    - 将浅拷贝改为深拷贝

- 赋值运算符，如果没有定义;

- 地址运算符，如果没有定义。

## 2.空指针

- char * str = 0;
- char * str = nullptr;//c++新增关键字
- char * str = (void *)0;//不可用
- char * str = NULL;//c语言宏

## 3.静态类成员函数

- static 声明函数
- 不能通过实例对象调用函数
- 不能使用this指针，也不能访问成员
- 通过类名和作用域解析符调用

## 4.构造函数中使用new的注意事项

- 如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete;
- new和delete必须相互兼容。new对应于delete，new[]对应于delete[ ]；
- 多个构造函数使用相同的new类型；
- 定义复制构造函数，通过深度复制将对象初始化为另一个对象；
- 定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象；（先检查自我赋值，释放之前的指针，返回一个当前对象的引用）
- 如果成员中的所有类型都处理好了复制构造函数，甚至可以不写复制构造函数；但要是有一个没有处理，需要写一个复制构造函数处理，同时显式调用处理好的复制构造函数

## 5.new和delete

- 使用定位new时

  ```
  const char *buffer[512];
  StringBad *pt = new(buffer) Stringbad;
  pt->~StringBad();//显示调用析构函数
  delete [] buffer;//delete buffer时不会调用保存对象的析构函数
  ```

  