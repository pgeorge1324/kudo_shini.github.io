# 堆栈内存管理

### 变量作用域

```
class complex{}...// 声明一个复数类

// 作用域
{
	complex c1(1,2); // 局部变量，存储在当前作用域的栈里
	complex *p = new complex(3);// p指向的地址在堆中不会自动销毁
	static complex c2(2,3);// static object 一直到整个程序结束才会销毁
	delete p;// 手动回收指针
}

complex c3(3,4);// 全局变量
```

### new关键字的操作

```
new:
1.先分配足够内存
2.调用该对象的构造函数

complex *p = new complex(1,2);
<==>
void *mem = operator new(sizeof(complex));// 分配内存 operator new会调用malloc(n)
p = static_cast<complex*>(mem);// 转换类型 把void*转成complex*
p->Complex::Complex(1,2);// 调用构造函数
```

### delete关键字的操作

```
delete:
1.先调用该对象的析构函数
2.释放内存

delete p;
<==>
String::~String(p);// 调用析构函数
operator delte(p);// 释放内存 operator delete内部调用free(p)
```

### （vc编译器）调试模式下的内存管理：

![image-20210220144539318](E:\github\notebook\c++\assets\内存管理1.png)

8byte(object size)+32byte(debug header)+4byte(debug tail)+4byte(cookie header)+4byte(cookie tail) = 52byte +12byte(padding)= 64 byte

【cookie内容】:00000041 = 16进制64 00000040+ 00000001（表示程序使用中，最后一个bit用来标识状态，所以内存大小必须是16的倍数）

当这块内存释放后变成00000040，表示这块64byte的内存已经回收

### （vc编译器）发布模式下的内存管理：

![image-20210220144921681](E:\github\notebook\c++\assets\内存管理2.png)

8byte（object size）+4byte(cookie header)+4byte(cookie tail) = 16byte 

【cookie内容】:00000011 = 16进制16 00000010+ 00000001（表示程序使用中）

### new[] (array new)动态分配所得的数组

```
// array new 一定要搭配array delete(如果对象没有指针，array delete能用但是不合理)

string *p = new string[3];
delete[] p;// 正确

string *p = new string[3];
delete p;// 错误 p[1]和p[2]字符串的内存因为没有调用析构函数而没有释放
```

### (vc编译器)调试模式下的数组内存管理

![image-20210220150501822](E:\github\notebook\c++\assets\内存管理3.png)

8byte(object size)*3 + 32byte（debug header） + 4byte (debug tail) + 4byte (cookie header)+ 4byte(cookie tail) + 4byte(array size) = 72 byte + 8byte(padding) = 80byte

### (vc编译器)发布模式下的数组内存管理

同理