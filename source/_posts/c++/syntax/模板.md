---
date: 2021-05-13 14:26:52
title: 模板
tags:
- c++
- syntax
categories:
- [c++, syntax]
---

# static

## 静态变量/静态函数

```
class complex{
data members;// non-static data members 每个实例一份单独一份数据
static data members;// static data members 所有实例共享一份数据
member functions;// c1.real()<==>complex::real(&c1) &c1=this
static member functions;// 只能处理静态数据或者无数据 静态函数通过类名和实例都可以调用
// 函数永远只有一份 无论是静态的还是非静态的
}
```

# template 模板

## class template 类模板

```
template<typename T>
class foo{
	...
}
```

## function template 函数模板

```
template <class T> //编译器会根据实参对函数进行参数推导
void bar(const T&a){
	...
}
```

## member template 成员模板

```c++
template<class T1, class T2>
struct Pair {
    T1 first;
    T2 second; //first和second类型不需要一样
    Pair() : first(T1()), second(T2()) {}

    Pair(const T1 &a, const T2 &b)
            : first(T1()), second(T2()) {}

    // 成员模板
    template<class U1, class U2>
    Pair(Pair<U1, U2> &p)
            : first(p.first), second(p.second) {}
};
// T1是U1的父类，T2是U2的父类
// Base1* ptr = new Derived1; // up-cast
// 所以智能指针需要改成
template<typename T>
class pointerLikeClasses {

public:
    T &operator*() const {
        return *pt;
    }

    // ->在重载时不会被消耗，直到执行了函数
    T *operator->() const {
        return pt;
    }
	
	template<class T1>
    pointerLikeClasses(T1 *p) : pt(p) {}

private:
    T *pt;
};
```

## specialization 模板特化

full specialization 泛化

partial specialization 偏特化

```
template <class Key>
class hash{};

template<>
struct hash<char>{
	size_t operator()(char x) const {return x;}
}

template<>
struct hash<int>{
	size_t operator()(int x) const {return x;}
}

template<>
struct hash<long>{
	size_t operator()(long x) const {return x;}
}

// cout << hash<long>()(1000) << endl; 
```

## partial specialization 偏特化

- ```
  template<typename T,typename T2>
  class foo{}
  template<typename T2>
  class foo<bool,T2>{} // 个数模板偏特化
  ```

- ```
  template<typename T>
  class foo{}
  template<typename T>
  class foo<T*>{} // 范围模板偏特化
  
  // foo<string> obj1; 编译器使用非特化版本
  // foo<string*> obj2; 编译器使用范围偏特化版本
  ```

## template template parameter 模板模板参数

- ```c++
  template<typename T,template<typename T> class Container>
  class XCls{
  private:
      Container<T> c;
  }
  // 使用：
  template<typename T>
  using Lst = list<T,allocator<T>>;
  XCls<string,Lst> xcls1;
  // XCls<string,list> xcls2;错误,因为list模板需要指定两个类型，但此处只指定了一个
  ```

- ```c++
  template<typename T,template<typename T> class SmartPtr>
  class XCls{
  private:
      SmartPtr<T> c;
  }
  // 使用：
  XCls<string,shared_ptr> xcls1;
  XCls<string,auto_ptr> xcls1;
  // XCls<string,unique_ptr> xcls1; 错误：因为unique_ptr和weak_ptr的问题错误
  // XCls<string,weak_ptr> xcls1; 错误
  ```

## 指定默认模板

```c++
template<class T,class Sequence = deque<T>>
class stack{
protected:
	Sequence c;// 底层容器
}
// 使用默认模板
stack<int> s1;
stack<int,list<int>> s2;
```

## variadic templates(c++11)数量不定的模板参数

```c++
template<typename T,typename... Types>
void print (const&T arg1,const Types&... args){
	cout<< arg1 << endl;
    sizeof...(args); // 查看个数
	print(args...);
}
// 使用：
print(7.5,"hello",'c');
```



# namespace

## using directive: [using namespace std]

## using declaration:[usting std::cout]

## using directly:[std::cout]