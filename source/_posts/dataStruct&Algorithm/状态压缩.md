---
date: 2021-05-13 14:26:52
title: 状态压缩
tags:
- dataStruct&Algorithm
categories:
- [dataStruct&Algorithm]
---

# 状态压缩

使用bit位及bit位运算实现状态标记

## 示例

```c++
// 有n个位置需要标记
// 0 -- 1<<n 之间的数分别代表了所有位置不同标记状态的组合
// 例如：
// 0 : 全部未标记
// (1<<n)-1 : 全标记
// 6 : (110)第二个和第三个位置标记
for (int i = 1; i < (1 << n); i++) {
    // gcc内建函数，使用vs编译器无法编译
	// __builtin_ctz获取目标数据二进制形式中后缀中0的个数
	// __builtin_ctz(1) == 0
	// __builtin_ctz(2) == 1
	// __builtin_ctz(6) == 1
	// x代表最近标记的位置
	// i-(1<<x)代表加上这个标记之前已经有的标记位置
    // 因为i是递增的，所以i-(1<<x)之前肯定已经处理过了，直接复用结果states[y]
    int x = __builtin_ctz(i), y = i - (1 << x);
    states[i] = operate(states[y] , data[x]) ;
}

for (int j = 0; j < (1 << n); j++) {
    // j代表了一种标记状态
    // 比如j=12:
    // j的二进制为1100
    // 每次x-1相当于把x的最后一个1去掉
    // x = (x-1)&j 确保把最后一个1去掉时,x仍然是j所代表的标记状态的一种子状态
    // 例如j=12(1100) x=12
    // (x - 1)& j => (1011)&(1100) => (1000) => 8
    // 使用(x-1)&j可以快速遍历j包含的所有子状态
    for (int x = j; x; x = (x - 1) & j) {
        // 因为x和j-x之间不会有交叉的标记位置，所以j-x是x在j中的补集
        operate(states[x]);
    }
}
```

